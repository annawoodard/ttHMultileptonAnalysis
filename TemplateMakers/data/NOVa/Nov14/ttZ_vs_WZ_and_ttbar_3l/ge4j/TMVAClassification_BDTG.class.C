// Class: ReadBDTG
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTG
TMVA Release   : 4.1.2         [262402]
ROOT Release   : 5.32/00       [335872]
Creator        : abrinke1
Date           : Mon Nov 17 17:32:21 2014
Host           : Linux lxbuild168.cern.ch 2.6.18-308.16.1.el5 #1 SMP Thu Oct 4 14:02:28 CEST 2012 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /afs/crc.nd.edu/user/a/abrinke1/TMVAv412
Training events: 1476
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
BoostType: "Grad" [Boosting type for the trees in the forest]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
Shrinkage: "1.000000e-01" [Learning rate for GradBoost algorithm]
nCuts: "10" [Number of steps during node cut optimisation]
NNodesMax: "5" [Max number of nodes in tree]
NegWeightTreatment: "ignorenegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
AdaBoostBeta: "1.000000e+00" [Parameter for AdaBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "3" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "1476" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "40" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
MaxDepth: "3" [Max depth of the decision tree allowed]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 7
MT_of_everything              MT_of_everything              MT_of_everything              MT_of_everything                                                'F'    [242.910308838,2431.53515625]
numMediumBJets                numMediumBJets                numMediumBJets                numMediumBJets                                                  'I'    [0,4]
Match_ttZ_3l_Bbq              Match_ttZ_3l_Bbq              Match_ttZ_3l_Bbq              Match_ttZ_3l_Bbq                                                'F'    [-12.2884874344,2.26844215393]
Match_ttZ_3l_Bqq              Match_ttZ_3l_Bqq              Match_ttZ_3l_Bqq              Match_ttZ_3l_Bqq                                                'F'    [-13.8958292007,1.98143649101]
Match_ttZ_3l_bqq              Match_ttZ_3l_bqq              Match_ttZ_3l_bqq              Match_ttZ_3l_bqq                                                'F'    [-11.5407123566,2.06617999077]
Match_ttZ_3l_Bbqq             Match_ttZ_3l_Bbqq             Match_ttZ_3l_Bbqq             Match_ttZ_3l_Bbqq                                               'F'    [-18.4680614471,2.223300457]
ZLike_mass_leplep_SFOS_all    ZLike_mass_leplep_SFOS_all    ZLike_mass_leplep_SFOS_all    ZLike_mass_leplep_SFOS_all                                      'F'    [81.0147857666,100.995048523]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTGNode
   
#ifndef BDTGNode__def
#define BDTGNode__def
   
class BDTGNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTGNode ( BDTGNode* left,BDTGNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTGNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTGNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTGNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTGNode*   fLeft;     // pointer to the left daughter node
   BDTGNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTGNode::~BDTGNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTGNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTGNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTG : public IClassifierReader {

 public:

   // constructor
   ReadBDTG( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDTG" ),
        fNvars( 7 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "MT_of_everything", "numMediumBJets", "Match_ttZ_3l_Bbq", "Match_ttZ_3l_Bqq", "Match_ttZ_3l_bqq", "Match_ttZ_3l_Bbqq", "ZLike_mass_leplep_SFOS_all" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 242.910308837891;
      fVmax[0] = 2431.53515625;
      fVmin[1] = 0;
      fVmax[1] = 4;
      fVmin[2] = -12.2884874343872;
      fVmax[2] = 2.26844215393066;
      fVmin[3] = -13.8958292007446;
      fVmax[3] = 1.98143649101257;
      fVmin[4] = -11.5407123565674;
      fVmax[4] = 2.06617999076843;
      fVmin[5] = -18.4680614471436;
      fVmax[5] = 2.22330045700073;
      fVmin[6] = 81.0147857666016;
      fVmax[6] = 100.995048522949;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'I';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTG() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[7];
   double fVmax[7];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[7];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTGNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTG::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTGNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTGNode*)current->GetRight();
         else current=(BDTGNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDTG::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.813084,0.0626168) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.484127,-0.0031746) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.203349,-0.0593301) , 
2, -1.89792, 0, 0, 0.372137,-0.127863) , 
5, -1.53877, 0, 0, 0.5,0)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.813084,0.0565846) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.599237,0.020165) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.296438,-0.0374825) , 
2, -0.599103, 0, 0, 0.372137,-0.11509) , 
5, -1.53877, 0, 0, 0.5,1.99346e-06)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.633565,0.0227818) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.278846,-0.035963) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0828025,-0.0749451) , 
1, 0.272727, 0, 0, 0.21322,-0.242921) , 
2, -1.70163, 0, 0, 0.5,2.24643e-05)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.813084,0.0496047) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.599237,0.0158973) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.296438,-0.0321629) , 
2, -0.599103, 0, 0, 0.372137,-0.0993294) , 
5, -1.53877, 0, 0, 0.5,-1.8758e-05)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680628,0.0280686) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.541667,0.00410462) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.233456,-0.0406324) , 
2, -0.777216, 0, 0, 0.30618,-0.146993) , 
5, -3.4198, 0, 0, 0.5,1.14683e-05)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.813084,0.0431092) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.429929,-0.0076059) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.135922,-0.057144) , 
1, 0.363636, 0, 0, 0.372137,-0.0839719) , 
5, -1.53877, 0, 0, 0.5,-1.46277e-05)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.633565,0.0172472) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.278846,-0.0268652) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0828025,-0.0606142) , 
1, 0.272727, 0, 0, 0.21322,-0.179479) , 
2, -1.70163, 0, 0, 0.5,1.66142e-06)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680628,0.0230552) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.411348,-0.00157349) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.237209,-0.0397708) , 
0, 667.817, 0, 0, 0.30618,-0.117985) , 
5, -3.4198, 0, 0, 0.5,-5.48056e-05)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.813084,0.0365275) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.407692,-0.00702605) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.137681,-0.0615994) , 
6, 95.5459, 1, 0, 0.372137,-0.068296) , 
5, -1.53877, 0, 0, 0.5,-6.35805e-05)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.633565,0.0145971) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.278846,-0.0221568) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0828025,-0.0550144) , 
1, 0.272727, 0, 0, 0.21322,-0.149088) , 
2, -1.70163, 0, 0, 0.5,-3.04031e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.750524,0.0299487) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.647287,0.0177961) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.287449,-0.0255383) , 
4, -0.514381, 0, 0, 0.38038,-0.0667844) , 
2, -0.378272, 0, 0, 0.5,-8.14403e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.750524,0.0273437) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.423313,-0.00466551) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.190217,-0.0504798) , 
0, 441.876, 0, 0, 0.38038,-0.060143) , 
2, -0.378272, 0, 0, 0.5,-6.83529e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.753394,0.0289689) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436019,-0.00394613) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.194737,-0.0486714) , 
0, 441.876, 0, 0, 0.391683,-0.0554048) , 
4, -0.4078, 0, 0, 0.5,-5.78096e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536398,0.00650704) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.28866,-0.0357564) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.135135,-0.0688708) , 
0, 514.711, 0, 0, 0.222222,-0.226264) , 
6, 95.5459, 1, 0, 0.5,-4.76615e-05)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.633565,0.0116087) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.28692,-0.0129468) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.137931,-0.0411654) , 
2, -2.66408, 0, 0, 0.21322,-0.115626) , 
2, -1.70163, 0, 0, 0.5,-5.88201e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.537954,0.00777375) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.571429,0.0248617) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.279279,-0.0468097) , 
0, 774.771, 0, 0, 0.325758,-0.16073) , 
6, 86.464, 0, 0, 0.5,-9.26046e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680628,0.0161685) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.411348,0.0029636) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.237209,-0.0309388) , 
0, 667.817, 0, 0, 0.30618,-0.0780046) , 
5, -3.4198, 0, 0, 0.5,-8.74804e-05)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536398,0.0059683) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.32,-0.0225129) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.181818,-0.0561996) , 
6, 96.5398, 1, 0, 0.222222,-0.204544) , 
6, 95.5459, 1, 0, 0.5,-9.54912e-05)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00721628) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.326531,-0.0257461) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.135593,-0.0674445) , 
6, 86.4595, 0, 0, 0.282353,-0.155258) , 
0, 441.876, 0, 0, 0.5,-0.00010264)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.750524,0.0230789) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.406321,-0.00562679) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.176991,-0.0517802) , 
6, 84.6476, 0, 0, 0.38038,-0.0488211) , 
2, -0.378272, 0, 0, 0.5,-0.000105749)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559011,0.00639003) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.263158,-0.0232841) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.116438,-0.049724) , 
0, 623.172, 0, 0, 0.166667,-0.16254) , 
1, 0.363636, 0, 0, 0.5,-9.0658e-05)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536398,0.00549973) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.28866,-0.0302268) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.135135,-0.0605904) , 
0, 514.711, 0, 0, 0.222222,-0.18619) , 
6, 95.5459, 1, 0, 0.5,-0.000117656)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.753394,0.0239184) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.417845,-0.0045257) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.182609,-0.0515954) , 
6, 84.6476, 0, 0, 0.391683,-0.0435585) , 
4, -0.4078, 0, 0, 0.5,-0.000124231)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701595,0.0220076) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.437693,-0.00587887) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0757576,-0.0647191) , 
6, 97.3489, 1, 0, 0.414658,-0.0410694) , 
1, 1.09091, 0, 0, 0.5,-0.000106453)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.537954,0.00656778) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.571429,0.0235791) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.279279,-0.0405722) , 
0, 774.771, 0, 0, 0.325758,-0.1314) , 
6, 86.464, 0, 0, 0.5,-0.000106403)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680628,0.0135467) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.342419,-0.00800387) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.136,-0.0465797) , 
6, 86.464, 0, 0, 0.30618,-0.0630419) , 
5, -3.4198, 0, 0, 0.5,-0.000104386)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00628104) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.364198,-0.0186937) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.139785,-0.054956) , 
0, 369.508, 0, 0, 0.282353,-0.13118) , 
0, 441.876, 0, 0, 0.5,-0.000110891)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559011,0.00562618) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19774,-0.0313176) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0444444,-0.0575872) , 
3, -3.73508, 0, 0, 0.166667,-0.140067) , 
1, 0.363636, 0, 0, 0.5,-0.00011913)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536398,0.0049523) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.32,-0.0187948) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.181818,-0.0481645) , 
6, 96.5398, 1, 0, 0.222222,-0.163667) , 
6, 95.5459, 1, 0, 0.5,-0.000138663)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.633565,0.00849822) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.28692,-0.00711191) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.137931,-0.0347737) , 
2, -2.66408, 0, 0, 0.21322,-0.0808877) , 
2, -1.70163, 0, 0, 0.5,-0.000141764)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.753394,0.0200941) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.493734,0.00874279) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.327559,-0.0190934) , 
0, 640.842, 0, 0, 0.391683,-0.0351075) , 
4, -0.4078, 0, 0, 0.5,-0.000156692)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536398,0.00449351) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.285714,-0.0230135) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.16092,-0.0496655) , 
6, 97.5298, 1, 0, 0.222222,-0.146622) , 
6, 95.5459, 1, 0, 0.5,-0.000135666)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.537954,0.00589722) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.571429,0.0227636) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.279279,-0.0372082) , 
0, 774.771, 0, 0, 0.325758,-0.114687) , 
6, 86.464, 0, 0, 0.5,-0.000138)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701595,0.0191829) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.504,0.00695388) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364048,-0.0172904) , 
0, 640.842, 0, 0, 0.414658,-0.0345496) , 
1, 1.09091, 0, 0, 0.5,-0.000133019)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559011,0.00487289) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19774,-0.027611) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0444444,-0.0544672) , 
3, -3.73508, 0, 0, 0.166667,-0.118789) , 
1, 0.363636, 0, 0, 0.5,-0.000115482)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00530951) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.333333,-0.017322) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.166667,-0.0505865) , 
6, 88.2744, 0, 0, 0.282353,-0.107965) , 
0, 441.876, 0, 0, 0.5,-0.000130735)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536398,0.00420441) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.304348,-0.0244677) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0535714,-0.0566649) , 
5, -6.65935, 0, 0, 0.222222,-0.135511) , 
6, 95.5459, 1, 0, 0.5,-0.000130168)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680628,0.0111068) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.342419,-0.00606586) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.136,-0.0423472) , 
6, 86.464, 0, 0, 0.30618,-0.0496966) , 
5, -3.4198, 0, 0, 0.5,-0.000139245)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701595,0.0170829) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.452206,-0.00162969) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.276018,-0.0300452) , 
6, 93.7191, 1, 0, 0.414658,-0.0301504) , 
1, 1.09091, 0, 0, 0.5,-0.000140276)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.526475,0.00382848) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.440678,-0.0148201) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.168421,-0.0450162) , 
3, -0.607696, 0, 0, 0.272727,-0.136328) , 
6, 84.6476, 0, 0, 0.5,-0.000126834)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54973,0.00392937) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.173469,-0.0201804) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0987654,-0.0459346) , 
3, -4.58185, 0, 0, 0.139665,-0.119523) , 
2, -3.02499, 0, 0, 0.5,-0.000127143)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00483548) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.364198,-0.0135869) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.139785,-0.0473051) , 
0, 369.508, 0, 0, 0.282353,-0.0966267) , 
0, 441.876, 0, 0, 0.5,-0.000137454)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.939394,0.0475292) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508415,0.00234068) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.28629,-0.0272607) , 
6, 86.464, 0, 0, 0.46841,-0.0118308) , 
5, 0.342268, 0, 0, 0.5,-0.000139282)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540564,0.00546777) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.425641,-0.00875652) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.2,-0.0470218) , 
0, 496.418, 0, 0, 0.344262,-0.0864918) , 
6, 93.7295, 1, 0, 0.5,-0.000105053)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559011,0.00433776) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19774,-0.0251639) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0444444,-0.0512745) , 
3, -3.73508, 0, 0, 0.166667,-0.102798) , 
1, 0.363636, 0, 0, 0.5,-0.000104784)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.753394,0.0163807) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.493734,0.00657579) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.327559,-0.0152276) , 
0, 640.842, 0, 0, 0.391683,-0.0269147) , 
4, -0.4078, 0, 0, 0.5,-0.000116995)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522744,0.00256296) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.270833,-0.0220001) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0232558,-0.0723476) , 
0, 514.711, 0, 0, 0.153846,-0.159479) , 
6, 97.3623, 1, 0, 0.5,-0.000101439)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544601,0.0038712) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.376623,-0.00777501) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.107438,-0.0398932) , 
2, -2.45128, 0, 0, 0.212121,-0.101435) , 
5, -9.0629, 0, 0, 0.5,-0.00011124)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.537954,0.00460647) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.571429,0.0257412) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.279279,-0.0313974) , 
0, 774.771, 0, 0, 0.325758,-0.0855032) , 
6, 86.464, 0, 0, 0.5,-0.000121606)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540564,0.00486705) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433628,-0.0102478) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0886076,-0.0505034) , 
5, -6.95379, 0, 0, 0.344262,-0.0759587) , 
6, 93.7295, 1, 0, 0.5,-0.000117498)    );
  // itree = 50
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701595,0.0148645) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.504,0.00603118) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364048,-0.0137822) , 
0, 640.842, 0, 0, 0.414658,-0.0251815) , 
1, 1.09091, 0, 0, 0.5,-0.000124778)    );
  // itree = 51
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559011,0.00382873) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.263158,-0.0141082) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.116438,-0.0358106) , 
0, 623.172, 0, 0, 0.166667,-0.0892641) , 
1, 0.363636, 0, 0, 0.5,-0.0001097)    );
  // itree = 52
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.526475,0.00316641) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.440678,-0.0111442) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.168421,-0.0391324) , 
3, -0.607696, 0, 0, 0.272727,-0.108901) , 
6, 84.6476, 0, 0, 0.5,-0.000116959)    );
  // itree = 53
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680628,0.0088749) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.411348,0.00245587) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.237209,-0.0186891) , 
0, 667.817, 0, 0, 0.30618,-0.0378254) , 
5, -3.4198, 0, 0, 0.5,-0.000116105)    );
  // itree = 54
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54973,0.00330791) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.173469,-0.0164185) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0987654,-0.0418084) , 
3, -4.58185, 0, 0, 0.139665,-0.0968536) , 
2, -3.02499, 0, 0, 0.5,-0.000111767)    );
  // itree = 55
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536398,0.00324496) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.247423,-0.03838) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.189189,-0.0108476) , 
3, -1.96184, 0, 0, 0.222222,-0.0991237) , 
6, 95.5459, 1, 0, 0.5,-0.000118879)    );
  // itree = 56
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.939394,0.0433984) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508415,0.00205071) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.28629,-0.023452) , 
6, 86.464, 0, 0, 0.46841,-0.00957779) , 
5, 0.342268, 0, 0, 0.5,-0.000112689)    );
  // itree = 57
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00393607) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.333333,-0.0118996) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.166667,-0.0429376) , 
6, 88.2744, 0, 0, 0.282353,-0.0751355) , 
0, 441.876, 0, 0, 0.5,-8.48594e-05)    );
  // itree = 58
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540564,0.00437482) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.425641,-0.00644015) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.2,-0.0402624) , 
0, 496.418, 0, 0, 0.344262,-0.066489) , 
6, 93.7295, 1, 0, 0.5,-8.5634e-05)    );
  // itree = 59
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559011,0.00349398) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19774,-0.0207426) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0444444,-0.0469313) , 
3, -3.73508, 0, 0, 0.166667,-0.0797622) , 
1, 0.363636, 0, 0, 0.5,-8.53771e-05)    );
  // itree = 60
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544601,0.00328067) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.376623,-0.00664156) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.107438,-0.0356328) , 
2, -2.45128, 0, 0, 0.212121,-0.0832335) , 
5, -9.0629, 0, 0, 0.5,-9.36253e-05)    );
  // itree = 61
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522744,0.0021089) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.227273,-0.0146164) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0851064,-0.0596133) , 
6, 99.3649, 0, 0, 0.153846,-0.126647) , 
6, 97.3623, 1, 0, 0.5,-0.000101127)    );
  // itree = 62
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.537954,0.00382814) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.571429,0.0256902) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.279279,-0.0273265) , 
0, 774.771, 0, 0, 0.325758,-0.0685803) , 
6, 86.464, 0, 0, 0.5,-0.000103848)    );
  // itree = 63
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701595,0.0127913) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.504,0.00490267) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364048,-0.0117001) , 
0, 640.842, 0, 0, 0.414658,-0.0208267) , 
1, 1.09091, 0, 0, 0.5,-0.000100132)    );
  // itree = 64
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.753394,0.0131893) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.417845,-0.00236346) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.182609,-0.0306098) , 
6, 84.6476, 0, 0, 0.391683,-0.0203754) , 
4, -0.4078, 0, 0, 0.5,-8.80058e-05)    );
  // itree = 65
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540564,0.00397335) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433628,-0.00758707) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0886076,-0.0462493) , 
5, -6.95379, 0, 0, 0.344262,-0.0593888) , 
6, 93.7295, 1, 0, 0.5,-8.08647e-05)    );
  // itree = 66
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54973,0.00283247) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.188889,-0.0124712) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0898876,-0.0384308) , 
4, -4.5362, 0, 0, 0.139665,-0.0806634) , 
2, -3.02499, 0, 0, 0.5,-8.84466e-05)    );
  // itree = 67
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.939394,0.0402158) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508415,0.00159887) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.28629,-0.0196269) , 
6, 86.464, 0, 0, 0.46841,-0.00804098) , 
5, 0.342268, 0, 0, 0.5,-9.52828e-05)    );
  // itree = 68
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559011,0.00309411) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.263158,-0.0108596) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.116438,-0.0311189) , 
0, 623.172, 0, 0, 0.166667,-0.0690294) , 
1, 0.363636, 0, 0, 0.5,-7.16827e-05)    );
  // itree = 69
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522744,0.0019273) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.227273,-0.0131435) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0851064,-0.0566129) , 
6, 99.3649, 0, 0, 0.153846,-0.113149) , 
6, 97.3623, 1, 0, 0.5,-7.72713e-05)    );
  // itree = 70
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00336223) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.356589,-0.00423972) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.206349,-0.0339986) , 
0, 387.594, 0, 0, 0.282353,-0.0623111) , 
0, 441.876, 0, 0, 0.5,-8.11819e-05)    );
  // itree = 71
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701595,0.0113195) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511111,0.0126825) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.400222,-0.007565) , 
0, 839.808, 0, 0, 0.414658,-0.0179095) , 
1, 1.09091, 0, 0, 0.5,-8.00004e-05)    );
  // itree = 72
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544601,0.00282839) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.280702,-0.00988879) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.119048,-0.0369977) , 
0, 679.518, 0, 0, 0.212121,-0.0697559) , 
5, -9.0629, 0, 0, 0.5,-6.97011e-05)    );
  // itree = 73
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540564,0.00356249) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.425641,-0.00450986) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.2,-0.0352657) , 
0, 496.418, 0, 0, 0.344262,-0.0523346) , 
6, 93.7295, 1, 0, 0.5,-7.31782e-05)    );
  // itree = 74
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536813,0.00442814) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636364,0.0309659) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356083,-0.0214884) , 
0, 773.848, 0, 0, 0.401985,-0.0445983) , 
6, 88.2803, 0, 0, 0.5,-7.23277e-05)    );
  // itree = 75
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680628,0.00695941) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.411348,0.00212781) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.237209,-0.0150599) , 
0, 667.817, 0, 0, 0.30618,-0.0280225) , 
5, -3.4198, 0, 0, 0.5,-6.73406e-05)    );
  // itree = 76
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54973,0.0025529) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.173469,-0.0114957) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0987654,-0.0363443) , 
3, -4.58185, 0, 0, 0.139665,-0.0710286) , 
2, -3.02499, 0, 0, 0.5,-6.50752e-05)    );
  // itree = 77
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.939394,0.0376729) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.697228,0.007772) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.35022,-0.00695971) , 
2, -0.599103, 0, 0, 0.46841,-0.00693089) , 
5, 0.342268, 0, 0, 0.5,-7.13074e-05)    );
  // itree = 78
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522744,0.00172791) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.270833,-0.0116714) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0232558,-0.063573) , 
0, 514.711, 0, 0, 0.153846,-0.0990672) , 
6, 97.3623, 1, 0, 0.5,-4.82775e-05)    );
  // itree = 79
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536813,0.00413995) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636364,0.0286434) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356083,-0.0200149) , 
0, 773.848, 0, 0, 0.401985,-0.0410528) , 
6, 88.2803, 0, 0, 0.5,-5.79211e-05)    );
  // itree = 80
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559011,0.0027204) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19774,-0.0165309) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0444444,-0.0418219) , 
3, -3.73508, 0, 0, 0.166667,-0.0591397) , 
1, 0.363636, 0, 0, 0.5,-5.40583e-05)    );
  // itree = 81
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540564,0.00334859) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433628,-0.00624249) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0886076,-0.0422236) , 
5, -6.95379, 0, 0, 0.344262,-0.0482441) , 
6, 93.7295, 1, 0, 0.5,-5.9928e-05)    );
  // itree = 82
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.526475,0.00220704) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.440678,-0.00531453) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.168421,-0.0304995) , 
3, -0.607696, 0, 0, 0.272727,-0.0704558) , 
6, 84.6476, 0, 0, 0.5,-6.63552e-05)    );
  // itree = 83
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00285198) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.356589,-0.002309) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.206349,-0.0309667) , 
0, 387.594, 0, 0, 0.282353,-0.0514265) , 
0, 441.876, 0, 0, 0.5,-6.6479e-05)    );
  // itree = 84
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.939394,0.0360755) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508415,0.0012971) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.28629,-0.0160474) , 
6, 86.464, 0, 0, 0.46841,-0.00627145) , 
5, 0.342268, 0, 0, 0.5,-6.53441e-05)    );
  // itree = 85
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540564,0.003162) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.425641,-0.00395866) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.2,-0.0320197) , 
0, 496.418, 0, 0, 0.344262,-0.0451756) , 
6, 93.7295, 1, 0, 0.5,-4.815e-05)    );
  // itree = 86
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54973,0.00226703) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.173469,-0.00989029) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0987654,-0.0338054) , 
3, -4.58185, 0, 0, 0.139665,-0.0617329) , 
2, -3.02499, 0, 0, 0.5,-4.85751e-05)    );
  // itree = 87
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559011,0.00249973) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.175824,-0.0208041) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.125,-0.00821774) , 
6, 93.843, 1, 0, 0.166667,-0.0536829) , 
1, 0.363636, 0, 0, 0.5,-5.43681e-05)    );
  // itree = 88
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.586762,0.00774717) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.863905,0.0229126) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.352941,-0.0101598) , 
5, -0.789319, 0, 0, 0.44711,-0.0176543) , 
0, 640.842, 0, 0, 0.5,-5.51108e-05)    );
  // itree = 89
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522744,0.00152479) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.227273,-0.00810948) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0851064,-0.051088) , 
6, 99.3649, 0, 0, 0.153846,-0.0855547) , 
6, 97.3623, 1, 0, 0.5,-4.14129e-05)    );
  // itree = 90
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536813,0.00364295) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636364,0.0265705) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356083,-0.0180149) , 
0, 773.848, 0, 0, 0.401985,-0.0353255) , 
6, 88.2803, 0, 0, 0.5,-4.62769e-05)    );
  // itree = 91
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544601,0.00236155) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.247706,-0.00592722) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.168539,-0.0311097) , 
6, 89.8711, 0, 0, 0.212121,-0.0558911) , 
5, -9.0629, 0, 0, 0.5,-4.31821e-05)    );
  // itree = 92
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701595,0.00914096) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.694118,0.0066307) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.323529,-0.00722256) , 
4, -0.226017, 0, 0, 0.414658,-0.0136295) , 
1, 1.09091, 0, 0, 0.5,-4.51523e-05)    );
  // itree = 93
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540564,0.00292132) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433628,-0.00512717) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0886076,-0.039434) , 
5, -6.95379, 0, 0, 0.344262,-0.0410153) , 
6, 93.7295, 1, 0, 0.5,-3.94152e-05)    );
  // itree = 94
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.586762,0.00697658) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.547009,0.00551958) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.342984,-0.0157248) , 
0, 495.962, 0, 0, 0.44711,-0.0157116) , 
0, 640.842, 0, 0, 0.5,-4.59671e-05)    );
  // itree = 95
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54973,0.00205061) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.188889,-0.00711815) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0898876,-0.0324755) , 
4, -4.5362, 0, 0, 0.139665,-0.0548348) , 
2, -3.02499, 0, 0, 0.5,-4.30774e-05)    );
  // itree = 96
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536813,0.00337209) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636364,0.0248232) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356083,-0.0166936) , 
0, 773.848, 0, 0, 0.401985,-0.0323279) , 
6, 88.2803, 0, 0, 0.5,-4.87169e-05)    );
  // itree = 97
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559011,0.00221482) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.175824,-0.018895) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.125,-0.00620935) , 
6, 93.843, 1, 0, 0.166667,-0.0466634) , 
1, 0.363636, 0, 0, 0.5,-4.50897e-05)    );
  // itree = 98
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522744,0.00138706) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.227273,-0.00734684) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0851064,-0.048309) , 
6, 99.3649, 0, 0, 0.153846,-0.0767753) , 
6, 97.3623, 1, 0, 0.5,-4.54821e-05)    );
  // itree = 99
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.939394,0.0331534) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.697228,0.00628113) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.35022,-0.00554546) , 
2, -0.599103, 0, 0, 0.46841,-0.00522084) , 
5, 0.342268, 0, 0, 0.5,-4.88935e-05)    );
   return;
};
 
// Clean up
inline void ReadBDTG::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDTG::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
